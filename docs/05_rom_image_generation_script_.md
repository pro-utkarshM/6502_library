# Chapter 5: ROM Image Generation Script

Welcome back to the `6502_library` tutorial! In the [previous chapter](04_rom_image_file_.md), we learned about the **ROM image file** (`rom.bin`) – the binary blueprint that contains all the bytes (your program's instructions and data) that need to be stored on the EEPROM. We saw that the `flash.py` script reads this file and writes its contents byte-by-byte to the chip.

But where does this `rom.bin` file come from? You don't create a 32,768-byte file manually! That's the job of the **ROM Image Generation Script**.

### Why Generate the ROM Image?

Imagine you've written your first small program in 6502 assembly language:

```assembly
  LDA #$FF
  STA $6002
  LDA #$55
  STA $6000
  LDA #$AA
  STA $6000
LOOP:
  JMP LOOP ; Stay in an infinite loop
```

When you use a 6502 assembler (like `vasm` or `ca65`), this assembly code gets translated into a sequence of raw machine code bytes. For example, `LDA #$FF` becomes `A9 FF`, `STA $6002` becomes `8D 02 60`, and so on.

So you end up with a sequence of bytes like: `A9 FF 8D 02 60 A9 55 8D 00 60 A9 AA 8D 00 60 4C 0F 80` (using a slightly different target address `$800F` for the loop jump than the example code in `make_rom.py` for clarity, but the principle is the same).

These bytes are your program! But just having these bytes isn't enough to create the final `rom.bin` file for a 32KB EEPROM. You also need to consider:

1.  **Where does the program live?** The 6502 needs to know *where* in the EEPROM to find the start of your program bytes. Your program might be designed to run starting at address `$8000` (a common convention in simple 6502 systems), not necessarily address `$0000`.
2.  **What about the Reset Vector?** This is crucial! The 6502 processor, when it starts up or is reset, doesn't just magically know where your program is. It looks at a very specific memory location – the **Reset Vector** – to find the starting address of the code it should execute. On the 6502, this vector is located at the very end of the available address space, specifically addresses `$FFFC` and `$FFFD`. In a system using a 32KB ROM mapped to the upper half of the 64KB address space (from `$8000` to `$FFFF`), the reset vector will be at `$7FFC` and `$7FFD` *within the 32KB ROM file*, which corresponds to the CPU's addresses `$FFFC` and `$FFFD`. The bytes stored at these two locations must be the *low byte* and *high byte* of your program's starting address.
3.  **What fills the rest of the space?** Your program might only be a few hundred bytes, but the EEPROM is 32,768 bytes large. The `rom.bin` file must be exactly 32,768 bytes long. The unused space needs to be filled with something – typically the `NOP` (No Operation) instruction (`$EA`) or just `$00`.

The **ROM Image Generation Script** (`make_rom.py` in this project) is a Python script that takes your raw program bytes, arranges them correctly within a 32KB structure, sets the reset vector, adds padding, and saves the result as `rom.bin`. It automates these necessary steps to produce a valid binary file ready for flashing.

### The Script: `make_rom.py`

Let's look at the `make_rom.py` script provided in the project. It's quite simple and demonstrates the core concepts:

```python
# flashrom/make_rom.py
code = bytearray([
  0xa9, 0xff,         # lda #$ff
  0x8d, 0x02, 0x60,   # sta $6002

  0xa9, 0x55,         # lda #$55
  0x8d, 0x00, 0x60,   # sta $6000

  0xa9, 0xaa,         # lda #$aa
  0x8d, 0x00, 0x60,   # sta $6000

  0x4c, 0x05, 0x80,   # jmp $8005 (Example: jumps to address $8005)
])

# Create a 32KB bytearray (32768 bytes)
# Start with the code, then pad the rest with 0xEA (NOP)
rom = code + bytearray([0xea] * (32768 - len(code)))

# Set the Reset Vector at addresses 0x7FFC and 0x7FFD
# These correspond to CPU addresses 0xFFFC and 0xFFFD when ROM is at 0x8000-0xFFFF
# The vector is set to 0x8005 (low byte 0x05, high byte 0x80)
rom[0x7ffc] = 0x05 # Low byte of reset address
rom[0x7ffd] = 0x80 # High byte of reset address

# Write the complete 32KB bytearray to the rom.bin file
with open("rom.bin", "wb") as out_file:
  out_file.write(rom)

print("[✓] rom.bin generated successfully.")
```

This script does the following steps:

1.  **Define the Program Bytes:** It starts with a Python `bytearray` called `code`. This `bytearray` holds the raw machine code bytes for a very small, simple 6502 program. In a real project, these bytes would typically be loaded from a file generated by a 6502 assembler.
2.  **Create the Full ROM Image (with padding):** It creates a new `bytearray` called `rom` with a total size of 32768 bytes (32KB). It does this by starting with the `code` bytearray and then adding enough `0xEA` bytes (the `NOP` instruction) to fill the remaining space up to 32768 bytes.
3.  **Set the Reset Vector:** This is a critical step. The script directly modifies the `rom` bytearray at two specific locations: `0x7ffc` and `0x7ffd`. It places the low byte (`0x05`) of the target address (`$8005`) at `0x7ffc` and the high byte (`0x80`) at `0x7ffd`. This sets the reset vector to `$8005`, telling the 6502 to start execution there after a reset. *Note:* In the provided example, the `code` bytes are placed starting at address 0 of the `rom` array, while the reset vector points to `$8005`. For the program to execute correctly, the `code` should ideally be placed starting at `$8005` within the `rom` bytearray, or the vector should point to `$0000`. This script demonstrates *how* to set the vector, and assumes your program bytes (`code`) will end up at the address the vector points to when loaded onto the hardware (e.g., by loading `code` into `rom[0x8005:]`). The current script puts the code at address 0 for simplicity in this example.
4.  **Save to File:** Finally, it opens a file named `rom.bin` in binary write mode (`"wb"`) and writes the entire 32KB `rom` bytearray to this file.

### How the Reset Vector Works

Let's take a closer look at the reset vector. The 6502 CPU has dedicated pins for its address bus (16 pins for 64KB addressing) and data bus (8 pins for bytes). When you reset the 6502, it internally performs the following sequence:

1.  It sets its address bus to `$FFFC`.
2.  It reads the byte at `$FFFC` using the data bus. This byte is expected to be the *low byte* of the starting address.
3.  It sets its address bus to `$FFFD`.
4.  It reads the byte at `$FFFD` using the data bus. This byte is expected to be the *high byte* of the starting address.
5.  It combines the low and high bytes to get the full 16-bit starting address (e.g., if low byte is `$05` and high byte is `$80`, the address is `$8005`).
6.  It then loads the instruction byte from this calculated starting address and begins executing the program from there.

In our 6502 computer built with RAM, ROM, etc., the hardware is designed such that when the 6502 puts `$FFFC` or `$FFFD` on its address bus, the circuit activates the EEPROM chip and accesses the very last two bytes stored in it. Our 32KB EEPROM is typically wired up to respond to addresses in the range `$8000` to `$FFFF`. The last two bytes of this range are `$FFFC` and `$FFFD`, which correspond to the last two bytes *within the 32KB chip itself*, at internal addresses `$7FFC` and `$7FFD` (since `$8000 + $7FFC = $FFFC$, and `$8000 + $7FFD = $FFFD`).

So, by putting `$05` at `rom[0x7ffc]` and `$80` at `rom[0x7ffd]` in our `make_rom.py` script, we are programming the last two bytes of the EEPROM such that when the 6502 reads `$FFFC`/`$FFFD` during reset, it gets `$05`/`$80$, forms the address `$8005$, and jumps to that location to start executing.

### How `make_rom.py` is Used

You don't typically run `make_rom.py` directly every time. The project's `Makefile` automates this. Recall the snippet from the `Makefile` in [Chapter 4](04_rom_image_file_.md):

```makefile
# flashrom/Makefile
# Name of the ROM binary file
ROM_BIN = rom.bin

# Python script to generate the ROM
MAKE_ROM = make_rom.py

# Rule to create the ROM binary file
$(ROM_BIN): $(MAKE_ROM)
	@echo "[+] Generating ROM binary..."
	# Run the make_rom.py script using python3
	python3 $(MAKE_ROM)

# ... rest of the Makefile ...
```

This `make` rule says that the target file `rom.bin` depends on the script `make_rom.py`. If you ask `make` to build `rom.bin` (or any target that *depends* on `rom.bin`, like `flash`), it will check if `rom.bin` exists and if `make_rom.py` has been modified since `rom.bin` was last created. If not, it runs the command `python3 make_rom.py`.

This means that whenever you run `make flash` (the command you'll use to program the EEPROM), `make` will first ensure `rom.bin` is up-to-date by running `make_rom.py`, which creates the fresh `rom.bin` file containing your latest program code, padding, and reset vector.

Here's a simple sequence diagram of the `make` process related to ROM generation:

![how](/assets/howx02.png)

### Summary

The `make_rom.py` script is a vital part of the workflow. It acts as the final step in preparing your program for the EEPROM after it's been assembled. It creates the necessary 32KB binary file (`rom.bin`) by:

*   Including your actual program bytes.
*   Filling the rest of the space with padding (like `0xEA`).
*   Crucially, setting the 6502 **reset vector** at the correct location (`$7FFC`/`$7FFD` within the 32KB file, mapping to CPU addresses `$FFFC`/`$FFFD`) to point to the starting address of your program (e.g., `$8005`).

This `rom.bin` file is then the input for the next stage: the EEPROM programmer script, which takes this digital blueprint and writes it onto the physical EEPROM chip byte by byte.

[Next Chapter: EEPROM Programmer Script](06_eeprom_programmer_script_.md)

---